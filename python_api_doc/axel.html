

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pymomentum.axel &mdash; PyMomentum  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pymomentum.geometry" href="geometry.html" />
    <link rel="prev" title="Welcome to PyMomentum" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyMomentum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">pymomentum.axel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.BoundingBox"><code class="docutils literal notranslate"><span class="pre">BoundingBox</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.__init__"><code class="docutils literal notranslate"><span class="pre">BoundingBox.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.center"><code class="docutils literal notranslate"><span class="pre">BoundingBox.center</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.contains"><code class="docutils literal notranslate"><span class="pre">BoundingBox.contains()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.extend"><code class="docutils literal notranslate"><span class="pre">BoundingBox.extend()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.max"><code class="docutils literal notranslate"><span class="pre">BoundingBox.max</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.BoundingBox.min"><code class="docutils literal notranslate"><span class="pre">BoundingBox.min</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.__init__"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.max_distance"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.max_distance</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.narrow_band_width"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.narrow_band_width</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig.tolerance"><code class="docutils literal notranslate"><span class="pre">MeshToSdfConfig.tolerance</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.__init__"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.bounds"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.bounds</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.fill"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.fill()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.gradient"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.grid_to_world"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.grid_to_world()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.is_valid_index"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.is_valid_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.resolution"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.resolution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.sample"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.sample_with_gradient"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.sample_with_gradient()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.total_voxels"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.total_voxels</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.voxel_size"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.voxel_size</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField.world_to_grid"><code class="docutils literal notranslate"><span class="pre">SignedDistanceField.world_to_grid()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.TriBvh"><code class="docutils literal notranslate"><span class="pre">TriBvh</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.__init__"><code class="docutils literal notranslate"><span class="pre">TriBvh.__init__()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.all_hits"><code class="docutils literal notranslate"><span class="pre">TriBvh.all_hits()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.any_hit"><code class="docutils literal notranslate"><span class="pre">TriBvh.any_hit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.box_query"><code class="docutils literal notranslate"><span class="pre">TriBvh.box_query()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.closest_hit"><code class="docutils literal notranslate"><span class="pre">TriBvh.closest_hit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.closest_surface_point"><code class="docutils literal notranslate"><span class="pre">TriBvh.closest_surface_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.line_hits"><code class="docutils literal notranslate"><span class="pre">TriBvh.line_hits()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.node_count"><code class="docutils literal notranslate"><span class="pre">TriBvh.node_count</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pymomentum.axel.TriBvh.primitive_count"><code class="docutils literal notranslate"><span class="pre">TriBvh.primitive_count</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.dual_contouring"><code class="docutils literal notranslate"><span class="pre">dual_contouring()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.fill_holes"><code class="docutils literal notranslate"><span class="pre">fill_holes()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.mesh_to_sdf"><code class="docutils literal notranslate"><span class="pre">mesh_to_sdf()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.smooth_mesh_laplacian"><code class="docutils literal notranslate"><span class="pre">smooth_mesh_laplacian()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#pymomentum.axel.triangulate_quads"><code class="docutils literal notranslate"><span class="pre">triangulate_quads()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="geometry.html">pymomentum.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="quaternion.html">pymomentum.quaternion</a></li>
<li class="toctree-l1"><a class="reference internal" href="skel_state.html">pymomentum.skel_state</a></li>
<li class="toctree-l1"><a class="reference internal" href="trs.html">pymomentum.trs</a></li>
<li class="toctree-l1"><a class="reference internal" href="backend.html">pymomentum.backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver.html">pymomentum.solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="solver2.html">pymomentum.solver2</a></li>
<li class="toctree-l1"><a class="reference internal" href="marker_tracking.html">pymomentum.marker_tracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="torch.html">pymomentum.torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="renderer.html">pymomentum.renderer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyMomentum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pymomentum.axel</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/axel.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pymomentum.axel">
<span id="pymomentum-axel"></span><h1>pymomentum.axel<a class="headerlink" href="#module-pymomentum.axel" title="Link to this heading"></a></h1>
<p>Python bindings for Axel library classes including SignedDistanceField.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">BoundingBox</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.BoundingBox.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pymomentum.axel.BoundingBox, min_corner: numpy.ndarray[numpy.float32[3, 1]], max_corner: numpy.ndarray[numpy.float32[3, 1]], id: int = 0) -&gt; None</p></li>
</ol>
<p>Create a bounding box from minimum and maximum corners.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_corner</strong> – Minimum corner of the bounding box (x, y, z).</p></li>
<li><p><strong>max_corner</strong> – Maximum corner of the bounding box (x, y, z).</p></li>
<li><p><strong>id</strong> – Optional ID for the bounding box (default: 0).</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pymomentum.axel.BoundingBox, center: numpy.ndarray[numpy.float32[3, 1]], thickness: float = 0.0) -&gt; None</p></li>
</ol>
<p>Create a bounding box centered at a point with given thickness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – Center point of the bounding box (x, y, z).</p></li>
<li><p><strong>thickness</strong> – Half-width in each dimension (default: 0.0).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.center">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.center" title="Link to this definition"></a></dt>
<dd><p>Get the center of the bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><span class="pre">pymomentum.axel.BoundingBox</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.contains" title="Link to this definition"></a></dt>
<dd><p>Check if a point is contained within the bounding box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> – Point to test (x, y, z).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the point is inside the bounding box.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><span class="pre">pymomentum.axel.BoundingBox</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.extend" title="Link to this definition"></a></dt>
<dd><p>Extend the bounding box to include a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> – Point to include (x, y, z).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.max">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.max" title="Link to this definition"></a></dt>
<dd><p>Get the maximum corner of the bounding box.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.BoundingBox.min">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min</span></span><a class="headerlink" href="#pymomentum.axel.BoundingBox.min" title="Link to this definition"></a></dt>
<dd><p>Get the minimum corner of the bounding box.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">MeshToSdfConfig</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><span class="pre">pymomentum.axel.MeshToSdfConfig</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.__init__" title="Link to this definition"></a></dt>
<dd><p>Create MeshToSdfConfig with default parameters.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.max_distance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_distance</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.max_distance" title="Link to this definition"></a></dt>
<dd><p>Maximum distance to compute (distances beyond this are clamped). Set to 0 to disable clamping. Default: 0</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.narrow_band_width">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">narrow_band_width</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.narrow_band_width" title="Link to this definition"></a></dt>
<dd><p>Narrow band width around triangles (in voxel units). Default: 1.5</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.MeshToSdfConfig.tolerance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tolerance</span></span><a class="headerlink" href="#pymomentum.axel.MeshToSdfConfig.tolerance" title="Link to this definition"></a></dt>
<dd><p>Numerical tolerance for computations. Default: machine epsilon * 1000</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">SignedDistanceField</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.__init__" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pymomentum.axel.SignedDistanceField, bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32[3, 1]], initial_value: float = 3.4028234663852886e+38) -&gt; None</p></li>
</ol>
<p>Create a signed distance field with given bounds and resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – 3D bounding box defining the spatial extent of the SDF.</p></li>
<li><p><strong>resolution</strong> – Grid resolution in each dimension (nx, ny, nz).</p></li>
<li><p><strong>initial_value</strong> – Initial distance value for all voxels (default: very far distance).</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pymomentum.axel.SignedDistanceField, bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32[3, 1]], data: list[float]) -&gt; None</p></li>
</ol>
<p>Create a signed distance field with given bounds, resolution, and initial data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – 3D bounding box defining the spatial extent of the SDF.</p></li>
<li><p><strong>resolution</strong> – Grid resolution in each dimension (nx, ny, nz).</p></li>
<li><p><strong>data</strong> – Initial distance values. Must have size nx * ny * nz.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.bounds">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bounds</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounding box of the SDF.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.fill" title="Link to this definition"></a></dt>
<dd><p>Fill the entire SDF with a constant value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> – The value to fill with.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.gradient" title="Link to this definition"></a></dt>
<dd><p>Sample the SDF gradient at continuous 3D positions.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get a 1D array of shape (3,)
- Batch positions: Pass 2D array of shape (N, 3) to get 2D array of shape (N, 3)</p>
<p>The gradient points in the direction of increasing distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Gradient vector(s) at the given position(s). Shape (3,) for single position, (N, 3) for batch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.grid_to_world">
<span class="sig-name descname"><span class="pre">grid_to_world</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.grid_to_world" title="Link to this definition"></a></dt>
<dd><p>Convert continuous grid coordinates to 3D world-space position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>grid_pos</strong> – Continuous grid coordinates.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>3D world-space position (x, y, z).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.is_valid_index">
<span class="sig-name descname"><span class="pre">is_valid_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.is_valid_index" title="Link to this definition"></a></dt>
<dd><p>Check if the given grid coordinates are within bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – Grid index in x dimension.</p></li>
<li><p><strong>j</strong> – Grid index in y dimension.</p></li>
<li><p><strong>k</strong> – Grid index in z dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if indices are within valid range.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.resolution">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resolution</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.resolution" title="Link to this definition"></a></dt>
<dd><p>Get the grid resolution as (nx, ny, nz).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.sample">
<span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.sample" title="Link to this definition"></a></dt>
<dd><p>Sample the SDF at continuous 3D positions using trilinear interpolation.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get a scalar result
- Batch positions: Pass 2D array of shape (N, 3) to get 1D array of N results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Interpolated signed distance value(s). Scalar for single position, 1D array for batch.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.sample_with_gradient">
<span class="sig-name descname"><span class="pre">sample_with_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.sample_with_gradient" title="Link to this definition"></a></dt>
<dd><p>Sample both the SDF value and gradient at continuous 3D positions.</p>
<p>Supports both single position and batch operations:
- Single position: Pass 1D array of shape (3,) to get tuple of (scalar, 1D array of shape (3,))
- Batch positions: Pass 2D array of shape (N, 3) to get tuple of (1D array of N values, 2D array of shape (N, 3))</p>
<p>More efficient than calling sample() and gradient() separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>positions</strong> – Position(s) to query. Either (3,) for single position or (N, 3) for batch of positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (value(s), gradient(s)) at the given position(s).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.total_voxels">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_voxels</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.total_voxels" title="Link to this definition"></a></dt>
<dd><p>Get the total number of voxels in the SDF.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.voxel_size">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">voxel_size</span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.voxel_size" title="Link to this definition"></a></dt>
<dd><p>Get the voxel size in each dimension as (dx, dy, dz).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.SignedDistanceField.world_to_grid">
<span class="sig-name descname"><span class="pre">world_to_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.SignedDistanceField.world_to_grid" title="Link to this definition"></a></dt>
<dd><p>Convert a 3D world-space position to continuous grid coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>position</strong> – 3D world-space position (x, y, z).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Continuous grid coordinates (may be fractional).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">TriBvh</span></span><a class="headerlink" href="#pymomentum.axel.TriBvh" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounding_box_thickness</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.__init__" title="Link to this definition"></a></dt>
<dd><p>Create a BVH (Bounding Volume Hierarchy) for triangle mesh ray and proximity queries.</p>
<p>The TriBvh accelerates spatial queries on triangle meshes including:
- Ray casting (closest hit, all hits, any hit)
- Closest point queries
- Bounding box overlap tests</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>bounding_box_thickness</strong> – Optional thickness to add to triangle bounding boxes for more robust queries.
Useful when triangles are very thin. Default: 0.0</p></li>
</ul>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a simple tetrahedron mesh</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Build BVH</span>
<span class="n">bvh</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">TriBvh</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>

<span class="c1"># Query closest point</span>
<span class="n">query_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">bvh</span><span class="o">.</span><span class="n">closest_surface_point</span><span class="p">(</span><span class="n">query_point</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closest point: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">point</span><span class="si">}</span><span class="s2">, on triangle: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">triangle_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.all_hits">
<span class="sig-name descname"><span class="pre">all_hits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.all_hits" title="Link to this definition"></a></dt>
<dd><p>Find all intersections for a single ray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> – Ray origin as 1D array of shape (3,).</p></li>
<li><p><strong>direction</strong> – Ray direction as 1D array of shape (3,).</p></li>
<li><p><strong>max_distance</strong> – Optional maximum distance for the ray. If not provided, uses infinity.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (triangle_ids, hit_distances, hit_points, bary_coords) where:
- triangle_ids: int32 array of shape (M,) with hit triangle indices
- hit_distances: float array of shape (M,) with hit distances
- hit_points: float array of shape (M, 3) with hit point positions
- bary_coords: float array of shape (M, 3) with barycentric coordinates
where M is the number of hits for this ray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.any_hit">
<span class="sig-name descname"><span class="pre">any_hit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">origins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.any_hit" title="Link to this definition"></a></dt>
<dd><p>Test if rays intersect the mesh for a batch of rays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origins</strong> – Ray origins as 2D array of shape (N, 3).</p></li>
<li><p><strong>directions</strong> – Ray directions as 2D array of shape (N, 3).</p></li>
<li><p><strong>max_distances</strong> – Optional maximum distances per ray as 1D array of shape (N,).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean numpy array of shape (N,) indicating if each ray hits the mesh.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.box_query">
<span class="sig-name descname"><span class="pre">box_query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">box</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><span class="pre">pymomentum.axel.BoundingBox</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.box_query" title="Link to this definition"></a></dt>
<dd><p>Find all triangles whose bounding boxes intersect with the query box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>box</strong> – Query bounding box.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of triangle indices that intersect the box.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.closest_hit">
<span class="sig-name descname"><span class="pre">closest_hit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">origins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.closest_hit" title="Link to this definition"></a></dt>
<dd><p>Find closest intersections for a batch of rays.</p>
<p>Supports batched queries for better performance when testing multiple rays.
Returns numpy arrays for efficient downstream processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origins</strong> – Ray origins as 2D array of shape (N, 3).</p></li>
<li><p><strong>directions</strong> – Ray directions as 2D array of shape (N, 3).</p></li>
<li><p><strong>max_distances</strong> – Optional maximum distances per ray as 1D array of shape (N,).
If not provided, uses default maximum distance.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (triangle_ids, hit_distances, hit_points, bary_coords) where:
- triangle_ids: int32 array of shape (N,) with hit triangle indices (-1 if no hit)
- hit_distances: float array of shape (N,) with hit distances (inf if no hit)
- hit_points: float array of shape (N, 3) with hit point positions
- bary_coords: float array of shape (N, 3) with barycentric coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.closest_surface_point">
<span class="sig-name descname"><span class="pre">closest_surface_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">queries</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.closest_surface_point" title="Link to this definition"></a></dt>
<dd><p>Find the closest points on the mesh surface for a batch of query points.</p>
<p>Returns numpy arrays for efficient downstream processing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>queries</strong> – Query points as 2D array of shape (N, 3).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (valid, points, triangle_indices, bary_coords) where:
- valid: bool array of shape (N,) indicating if query succeeded
- points: float array of shape (N, 3) with closest points on the mesh surface
- triangle_indices: uint32 array of shape (N,) with triangle indices (kInvalidTriangleIdx if invalid)
- bary_coords: float array of shape (N, 3) with barycentric coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.line_hits">
<span class="sig-name descname"><span class="pre">line_hits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.TriBvh" title="pymomentum.axel.TriBvh"><span class="pre">pymomentum.axel.TriBvh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.line_hits" title="Link to this definition"></a></dt>
<dd><p>Find all triangles hit by the infinite line defined by the ray direction.</p>
<p>Note: This queries the infinite line, not just the ray segment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> – Line origin as 1D array of shape (3,).</p></li>
<li><p><strong>direction</strong> – Line direction as 1D array of shape (3,).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>int32 array of triangle indices hit by the line.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.node_count">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node_count</span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.node_count" title="Link to this definition"></a></dt>
<dd><p>Total number of internal nodes in the BVH tree.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymomentum.axel.TriBvh.primitive_count">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">primitive_count</span></span><a class="headerlink" href="#pymomentum.axel.TriBvh.primitive_count" title="Link to this definition"></a></dt>
<dd><p>Total number of primitives (triangles) in the BVH.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.dual_contouring">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">dual_contouring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sdf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><span class="pre">pymomentum.axel.SignedDistanceField</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">isovalue</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangulate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.dual_contouring" title="Link to this definition"></a></dt>
<dd><p>Extract an isosurface from a signed distance field using dual contouring.</p>
<p>Dual contouring places vertices inside grid cells and generates quad faces between
adjacent cells that both contain vertices. This naturally produces quads rather than
triangles, which better preserves surface topology and reduces mesh artifacts.</p>
<p>The algorithm works by:
1. Finding all cells that intersect the isosurface (sign changes across cell corners)
2. Placing one vertex at each intersecting cell, positioned on the surface using gradient descent
3. Generating quads for each edge crossing that connects 4 adjacent cells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sdf</strong> – The <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a> to extract the isosurface from.</p></li>
<li><p><strong>isovalue</strong> – The isovalue to extract (typically 0.0 for zero level set). Default: 0.0</p></li>
<li><p><strong>triangulate</strong> – Whether to triangulate the quads (default: False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (vertices, normals, quads) where:
- vertices: 2D array of shape (N, 3) with vertex positions
- normals: 2D array of shape (N, 3) with vertex normals (computed from SDF gradients)
- quads: Quad indices of shape (M, 4) connecting the vertices</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a sphere SDF</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">(</span>
    <span class="n">min_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">]),</span>
    <span class="n">max_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>
<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">SignedDistanceField</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>

<span class="c1"># Fill with sphere distance values</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">grid_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">world_pos</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">grid_to_world</span><span class="p">(</span><span class="n">grid_pos</span><span class="p">)</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">world_pos</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>  <span class="c1"># Unit sphere</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distance</span><span class="p">)</span>

<span class="c1"># Extract mesh (always returns quads)</span>
<span class="n">vertices</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">dual_contouring</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">isovalue</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span><span class="si">}</span><span class="s2"> quads&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Vertex normals have shape: </span><span class="si">{</span><span class="n">normals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.fill_holes">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">fill_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">triangles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#pymomentum.axel.fill_holes" title="Link to this definition"></a></dt>
<dd><p>Fill holes in a triangle mesh to create a watertight surface.</p>
<p>This function identifies holes in the mesh and fills them with new triangles using
an advancing front method. The result is a complete mesh suitable for operations
that require watertight surfaces, such as SDF generation.</p>
<p>For small holes (≤6 vertices), a centroid-based fan triangulation is used.
For larger holes, an ear clipping algorithm is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>config</strong> – Configuration parameters as <code class="xref py py-class docutils literal notranslate"><span class="pre">MeshHoleFillingConfig</span></code> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (filled_vertices, filled_triangles) where:
- filled_vertices: 2D array of shape (N’, 3) with original + new vertices
- filled_triangles: 2D array of shape (M’, 3) with original + new triangles</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a cube mesh with a missing face (hole)</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>   <span class="c1"># top face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Missing top face triangles to create a hole</span>
<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="c1"># [4, 7, 6], [4, 6, 5],  # top face (missing - creates hole)</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># front face</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># back face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># left face</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>   <span class="c1"># right face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">MeshHoleFillingConfig</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">max_edge_length_ratio</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">config</span><span class="o">.</span><span class="n">smoothing_iterations</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">filled_vertices</span><span class="p">,</span> <span class="n">filled_triangles</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original mesh: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filled mesh: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filled_vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filled_triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.mesh_to_sdf">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">mesh_to_sdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymomentum.axel.mesh_to_sdf" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>mesh_to_sdf(vertices: numpy.ndarray[numpy.float32], triangles: numpy.ndarray[numpy.int32], bounds: pymomentum.axel.BoundingBox, resolution: numpy.ndarray[numpy.int32], config: pymomentum.axel.MeshToSdfConfig = MeshToSdfConfig(narrow_band_width=1.500, max_distance=0.000, tolerance=1.192093e-04)) -&gt; pymomentum.axel.SignedDistanceField</p></li>
</ol>
<p>Convert a triangle mesh to a signed distance field using modern 3-step approach.</p>
<p>This function creates a high-quality signed distance field from a triangle mesh using:
1. Narrow band initialization with exact triangle distances
2. Fast marching propagation using Eikonal equation
3. Sign determination using ray casting</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>bounds</strong> – Spatial bounds for the SDF as a <a class="reference internal" href="#pymomentum.axel.BoundingBox" title="pymomentum.axel.BoundingBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundingBox</span></code></a>.</p></li>
<li><p><strong>resolution</strong> – Grid resolution as 1D array of shape (3,) containing (nx, ny, nz).</p></li>
<li><p><strong>config</strong> – Configuration parameters as <a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a>.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a simple cube mesh</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]</span>   <span class="c1"># top face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># bottom face</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>  <span class="c1"># top face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># front face</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># back face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># left face</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>   <span class="c1"># right face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">bounds</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">(</span>
    <span class="n">min_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">]),</span>
    <span class="n">max_corner</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">MeshToSdfConfig</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">narrow_band_width</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">mesh_to_sdf</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>mesh_to_sdf(vertices: numpy.ndarray[numpy.float32], triangles: numpy.ndarray[numpy.int32], resolution: numpy.ndarray[numpy.int32], padding: float = 0.10000000149011612, config: pymomentum.axel.MeshToSdfConfig = MeshToSdfConfig(narrow_band_width=1.500, max_distance=0.000, tolerance=1.192093e-04)) -&gt; pymomentum.axel.SignedDistanceField</p></li>
</ol>
<p>Convert a triangle mesh to a signed distance field with automatic bounds computation.</p>
<p>This convenience function automatically computes the bounding box from the mesh vertices,
adds padding, and creates a signed distance field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>triangles</strong> – Triangle indices as 2D array of shape (M, 3) where M is number of triangles.</p></li>
<li><p><strong>resolution</strong> – Grid resolution as 1D array of shape (3,) containing (nx, ny, nz).</p></li>
<li><p><strong>padding</strong> – Extra space around mesh bounds as fraction of bounding box size (default: 0.1).</p></li>
<li><p><strong>config</strong> – Configuration parameters as <a class="reference internal" href="#pymomentum.axel.MeshToSdfConfig" title="pymomentum.axel.MeshToSdfConfig"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshToSdfConfig</span></code></a> (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated <a class="reference internal" href="#pymomentum.axel.SignedDistanceField" title="pymomentum.axel.SignedDistanceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignedDistanceField</span></code></a>.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Create a simple tetrahedron mesh</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">])</span>

<span class="c1"># Automatically compute bounds with 20% padding</span>
<span class="n">sdf</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">mesh_to_sdf</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.smooth_mesh_laplacian">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">smooth_mesh_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_mask</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=bool)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.smooth_mesh_laplacian" title="Link to this definition"></a></dt>
<dd><p>Smooth a triangle or quad mesh using Laplacian smoothing with optional vertex masking.</p>
<p>This function applies Laplacian smoothing to mesh vertices, where each vertex is moved toward
the average position of its neighboring vertices. Optionally, you can specify which vertices
to smooth using a boolean mask. Both triangle and quad meshes are supported automatically
based on the shape of the faces array.</p>
<p>The smoothing is applied iteratively using the formula:
new_position = (1 - step) * old_position + step * average_neighbor_position</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vertices</strong> – Vertex positions as 2D array of shape (N, 3) where N is number of vertices.</p></li>
<li><p><strong>faces</strong> – Face indices as 2D array of shape (M, 3) for triangles or (M, 4) for quads.
Indices must be valid within the vertices array.</p></li>
<li><p><strong>vertex_mask</strong> – Optional boolean mask of shape (N,) indicating which vertices to smooth.
If empty array or not provided, all vertices will be smoothed.</p></li>
<li><p><strong>iterations</strong> – Number of smoothing iterations to apply (default: 1).</p></li>
<li><p><strong>step</strong> – Smoothing step size between 0.0 and 1.0 (default: 0.5).
Smaller values preserve original shape better, larger values smooth more aggressively.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Smoothed vertex positions as 2D array of shape (N, 3).</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Example 1: Triangle mesh</span>
<span class="n">tri_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">tri_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Smooth all vertices of triangle mesh</span>
<span class="n">smoothed_tri</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">smooth_mesh_laplacian</span><span class="p">(</span>
    <span class="n">tri_vertices</span><span class="p">,</span> <span class="n">tri_faces</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Example 2: Quad mesh</span>
<span class="n">quad_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># 0</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># 1</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># 2</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>  <span class="c1"># 3</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  <span class="c1"># 4</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  <span class="c1"># 5</span>
    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>  <span class="c1"># 6</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>   <span class="c1"># 7</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">quad_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># Bottom face</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>  <span class="c1"># Top face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># Front face</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>  <span class="c1"># Back face</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># Left face</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>   <span class="c1"># Right face</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Smooth only internal vertices (exclude corners)</span>
<span class="n">vertex_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="n">smoothed_quad</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">smooth_mesh_laplacian</span><span class="p">(</span>
    <span class="n">quad_vertices</span><span class="p">,</span> <span class="n">quad_faces</span><span class="p">,</span> <span class="n">vertex_mask</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymomentum.axel.triangulate_quads">
<span class="sig-prename descclassname"><span class="pre">pymomentum.axel.</span></span><span class="sig-name descname"><span class="pre">triangulate_quads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pymomentum.axel.triangulate_quads" title="Link to this definition"></a></dt>
<dd><p>Triangulate a quad mesh into triangles.</p>
<p>Each quad is split into two triangles using the diagonal (0,2).
This converts a quad mesh (as produced by dual contouring) into a triangle mesh
suitable for rendering or processing with triangle-based algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quads</strong> – Quad indices as 2D array of shape (M, 4) where M is number of quads.
Each row contains 4 vertex indices defining a quad.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Triangle indices as 2D array of shape (2M, 3) where each quad produces 2 triangles.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pymomentum.axel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">axel</span>

<span class="c1"># Get quads from dual contouring</span>
<span class="n">vertices</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">quads</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">dual_contouring</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>

<span class="c1"># Convert to triangles if needed for rendering</span>
<span class="n">triangles</span> <span class="o">=</span> <span class="n">axel</span><span class="o">.</span><span class="n">triangulate_quads</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">quads</span><span class="p">)</span><span class="si">}</span><span class="s2"> quads to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span><span class="si">}</span><span class="s2"> triangles&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to PyMomentum" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="geometry.html" class="btn btn-neutral float-right" title="pymomentum.geometry" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>